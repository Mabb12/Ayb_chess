<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ú–∏–∫—Ä–æ-–®–∞—Ö–º–∞—Ç—ã 4x4</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        
        select {
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 2px;
            width: 400px;
            height: 400px;
            margin: 0 auto;
            border: 3px solid #8B4513;
            background: #DEB887;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            background: #F0D9B5;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 24px;
            font-weight: bold;
        }
        
        .cell.dark {
            background: #B58863;
        }
        
        .cell.selected {
            background: #AEC6CF !important;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }
        
        .cell.possible-move {
            background: #90EE90 !important;
        }
        
        .cell.possible-capture {
            background: #FFB6C1 !important;
        }
        
        .coordinates {
            position: absolute;
            font-size: 10px;
            color: rgba(0, 0, 0, 0.5);
        }
        
        .coord-col {
            bottom: 2px;
            right: 2px;
        }
        
        .coord-row {
            top: 2px;
            left: 2px;
        }
        
        .pawn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(0, 0, 0, 0.1);
        }
        
        .pawn.white {
            background: white;
            color: black;
        }
        
        .pawn.black {
            background: black;
            color: white;
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .status {
            text-align: center;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
        }
        
        .rules {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            font-size: 14px;
        }
        
        .moves-history {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
        }
        
        .move-record {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ –ú–∏–∫—Ä–æ-–®–∞—Ö–º–∞—Ç—ã 4x4</h1>
        
        <div class="game-info">
            <div id="currentPlayer">–•–æ–¥: –ë–µ–ª—ã–µ</div>
            <div id="gameMode">–†–µ–∂–∏–º: –ò–≥—Ä–æ–∫ vs –ò–≥—Ä–æ–∫</div>
        </div>
        
        <div class="controls">
            <select id="gameModeSelect">
                <option value="pvp">–ò–≥—Ä–æ–∫ vs –ò–≥—Ä–æ–∫</option>
                <option value="pve_easy">–ò–≥—Ä–æ–∫ vs –ë–æ—Ç (–õ–µ–≥–∫–∏–π)</option>
                <option value="pve_medium">–ò–≥—Ä–æ–∫ vs –ë–æ—Ç (–°—Ä–µ–¥–Ω–∏–π)</option>
                <option value="pve_hard">–ò–≥—Ä–æ–∫ vs –ë–æ—Ç (–°–ª–æ–∂–Ω—ã–π)</option>
                <option value="eve">–ë–æ—Ç vs –ë–æ—Ç</option>
            </select>
            <button id="newGameBtn">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
            <button id="undoBtn" disabled>–û—Ç–º–µ–Ω–∏—Ç—å —Ö–æ–¥</button>
        </div>
        
        <div class="board" id="board"></div>
        
        <div class="status" id="status">–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å! –•–æ–¥ –±–µ–ª—ã—Ö.</div>
        
        <div class="moves-history">
            <h3>–ò—Å—Ç–æ—Ä–∏—è —Ö–æ–¥–æ–≤:</h3>
            <div id="movesList"></div>
        </div>
        
        <div class="rules">
            <h3>üìã –ü—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã:</h3>
            <ul>
                <li><strong>–•–æ–¥ –ø–µ—à–∫–∏:</strong> –Ω–∞ 1 –∫–ª–µ—Ç–∫—É –≤–ø–µ—Ä—ë–¥ –∏–ª–∏ –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏ –≤–ø–µ—Ä—ë–¥</li>
                <li><strong>–í–∑—è—Ç–∏–µ:</strong> –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏ –∏–ª–∏ —Å–±–æ–∫—É (–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ)</li>
                <li><strong>–¶–µ–ª—å:</strong> –ø—Ä–æ–≤–µ—Å—Ç–∏ –ª—é–±—É—é –ø–µ—à–∫—É –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω—é—é –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å</li>
                <li><strong>–ó–∞—â–∏—Ç–∞:</strong> –ø–µ—à–∫–∞ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–π –ª–∏–Ω–∏–∏ –∑–∞—â–∏—â–µ–Ω–∞ –æ—Ç –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ –≤–∑—è—Ç–∏—è</li>
                <li><strong>–ü–∞—Ç:</strong> –µ—Å–ª–∏ –∏–≥—Ä–æ–∫ –Ω–µ –º–æ–∂–µ—Ç —Å–¥–µ–ª–∞—Ç—å —Ö–æ–¥ - –Ω–∏—á—å—è</li>
            </ul>
        </div>
    </div>

    <script>
        class MicroChess {
            constructor() {
                this.board = Array(4).fill().map(() => Array(4).fill(null));
                this.currentPlayer = 'white';
                this.selectedCell = null;
                this.possibleMoves = [];
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.setupBoard();
            }
            
            setupBoard() {
                // –ë–µ–ª—ã–µ –ø–µ—à–∫–∏ –Ω–∞ –ª–∏–Ω–∏–∏ 0 (a1-d1)
                for (let col = 0; col < 4; col++) {
                    this.board[0][col] = 'white';
                }
                // –ß–µ—Ä–Ω—ã–µ –ø–µ—à–∫–∏ –Ω–∞ –ª–∏–Ω–∏–∏ 3 (a4-d4)
                for (let col = 0; col < 4; col++) {
                    this.board[3][col] = 'black';
                }
            }
            
            getCellCoord(row, col) {
                const cols = ['a', 'b', 'c', 'd'];
                return cols[col] + (4 - row);
            }
            
            parseCoord(coord) {
                const cols = {'a': 0, 'b': 1, 'c': 2, 'd': 3};
                const colChar = coord[0];
                const rowChar = coord[1];
                return {
                    row: 4 - parseInt(rowChar),
                    col: cols[colChar]
                };
            }
            
            isValidMove(fromRow, fromCol, toRow, toCol) {
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–∑–æ–≤—ã—Ö —É—Å–ª–æ–≤–∏–π
                if (toRow < 0 || toRow > 3 || toCol < 0 || toCol > 3) return false;
                if (this.board[toRow][toCol] !== null) return false;
                if (this.board[fromRow][fromCol] !== this.currentPlayer) return false;
                
                const rowDiff = toRow - fromRow;
                const colDiff = toCol - fromCol;
                
                // –ë–µ–ª—ã–µ —Ö–æ–¥—è—Ç "–≤–Ω–∏–∑" (—É–≤–µ–ª–∏—á–∏–≤–∞—é—Ç row), —á–µ—Ä–Ω—ã–µ - "–≤–≤–µ—Ä—Ö" (—É–º–µ–Ω—å—à–∞—é—Ç row)
                if (this.currentPlayer === 'white') {
                    return (rowDiff === 1 && colDiff === 0) ||  // –≤–ø–µ—Ä–µ–¥
                           (rowDiff === 1 && Math.abs(colDiff) === 1); // –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏
                } else {
                    return (rowDiff === -1 && colDiff === 0) ||  // –≤–ø–µ—Ä–µ–¥
                           (rowDiff === -1 && Math.abs(colDiff) === 1); // –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏
                }
            }
            
            isValidCapture(fromRow, fromCol, toRow, toCol) {
                if (toRow < 0 || toRow > 3 || toCol < 0 || toCol > 3) return false;
                
                const target = this.board[toRow][toCol];
                const opponent = this.currentPlayer === 'white' ? 'black' : 'white';
                if (target !== opponent) return false;
                
                const rowDiff = toRow - fromRow;
                const colDiff = toCol - fromCol;
                
                // –í–æ–∑–º–æ–∂–Ω—ã–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤–∑—è—Ç–∏—è
                const captureDirections = this.currentPlayer === 'white' 
                    ? [[1, -1], [1, 1], [0, -1], [0, 1]]  // –¥–∏–∞–≥–æ–Ω–∞–ª–∏ + –±–æ–∫–æ–≤—ã–µ –¥–ª—è –±–µ–ª—ã—Ö
                    : [[-1, -1], [-1, 1], [0, -1], [0, 1]]; // –¥–∏–∞–≥–æ–Ω–∞–ª–∏ + –±–æ–∫–æ–≤—ã–µ –¥–ª—è —á–µ—Ä–Ω—ã—Ö
                
                return captureDirections.some(([dr, dc]) => dr === rowDiff && dc === colDiff);
            }
            
            getPossibleMoves(row, col) {
                const moves = [];
                if (this.board[row][col] !== this.currentPlayer) return moves;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –∫–ª–µ—Ç–∫–∏
                for (let toRow = 0; toRow < 4; toRow++) {
                    for (let toCol = 0; toCol < 4; toCol++) {
                        if (this.isValidMove(row, col, toRow, toCol)) {
                            moves.push({row: toRow, col: toCol, type: 'move'});
                        } else if (this.isValidCapture(row, col, toRow, toCol)) {
                            moves.push({row: toRow, col: toCol, type: 'capture'});
                        }
                    }
                }
                
                return moves;
            }
            
            makeMove(fromRow, fromCol, toRow, toCol) {
                const fromCoord = this.getCellCoord(fromRow, fromCol);
                const toCoord = this.getCellCoord(toRow, toCol);
                const isCapture = this.board[toRow][toCol] !== null;
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –æ—Ç–º–µ–Ω—ã —Ö–æ–¥–∞
                this.moveHistory.push({
                    fromRow, fromCol, toRow, toCol,
                    fromPiece: this.board[fromRow][fromCol],
                    toPiece: this.board[toRow][toCol],
                    player: this.currentPlayer
                });
                
                // –í—ã–ø–æ–ª–Ω—è–µ–º —Ö–æ–¥
                this.board[toRow][toCol] = this.board[fromRow][fromCol];
                this.board[fromRow][fromCol] = null;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏—è –ø–æ–±–µ–¥—ã
                this.checkWinCondition();
                
                if (!this.gameOver) {
                    this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                }
                
                return {
                    from: fromCoord,
                    to: toCoord,
                    capture: isCapture,
                    player: this.currentPlayer === 'white' ? 'black' : 'white'
                };
            }
            
            undoMove() {
                if (this.moveHistory.length === 0) return false;
                
                const lastMove = this.moveHistory.pop();
                this.board[lastMove.fromRow][lastMove.fromCol] = lastMove.fromPiece;
                this.board[lastMove.toRow][lastMove.toCol] = lastMove.toPiece;
                this.currentPlayer = lastMove.player;
                this.gameOver = false;
                this.winner = null;
                
                return true;
            }
            
            checkWinCondition() {
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–µ–π –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
                for (let col = 0; col < 4; col++) {
                    // –ë–µ–ª–∞—è –ø–µ—à–∫–∞ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–π –ª–∏–Ω–∏–∏ (—Ä—è–¥ 3)
                    if (this.board[3][col] === 'white') {
                        if (!this.canBeCaptured(3, col)) {
                            this.gameOver = true;
                            this.winner = 'white';
                            return;
                        }
                    }
                    // –ß–µ—Ä–Ω–∞—è –ø–µ—à–∫–∞ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–π –ª–∏–Ω–∏–∏ (—Ä—è–¥ 0)
                    if (this.board[0][col] === 'black') {
                        if (!this.canBeCaptured(0, col)) {
                            this.gameOver = true;
                            this.winner = 'black';
                            return;
                        }
                    }
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–∞—Ç
                if (!this.hasLegalMoves()) {
                    this.gameOver = true;
                    this.winner = null; // –ù–∏—á—å—è
                }
            }
            
            canBeCaptured(row, col) {
                const piece = this.board[row][col];
                const opponent = piece === 'white' ? 'black' : 'white';
                
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 4; c++) {
                        if (this.board[r][c] === opponent) {
                            const captureDirections = opponent === 'black' 
                                ? [[-1, -1], [-1, 1], [0, -1], [0, 1]]
                                : [[1, -1], [1, 1], [0, -1], [0, 1]];
                            
                            for (const [dr, dc] of captureDirections) {
                                const newRow = r + dr;
                                const newCol = c + dc;
                                if (newRow === row && newCol === col) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }
            
            hasLegalMoves() {
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 4; col++) {
                        if (this.board[row][col] === this.currentPlayer) {
                            if (this.getPossibleMoves(row, col).length > 0) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            getAllLegalMoves() {
                const moves = [];
                for (let fromRow = 0; fromRow < 4; fromRow++) {
                    for (let fromCol = 0; fromCol < 4; fromCol++) {
                        if (this.board[fromRow][fromCol] === this.currentPlayer) {
                            const possibleMoves = this.getPossibleMoves(fromRow, fromCol);
                            for (const move of possibleMoves) {
                                moves.push({
                                    fromRow, fromCol,
                                    toRow: move.row, toCol: move.col,
                                    type: move.type
                                });
                            }
                        }
                    }
                }
                return moves;
            }

            // –ú–µ—Ç–æ–¥ –¥–ª—è –∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –∏–≥—Ä—ã (–Ω—É–∂–µ–Ω –±–æ—Ç—É)
            clone() {
                const cloned = new MicroChess();
                cloned.board = this.board.map(row => [...row]);
                cloned.currentPlayer = this.currentPlayer;
                cloned.gameOver = this.gameOver;
                cloned.winner = this.winner;
                return cloned;
            }
        }

        class SmartBot {
            constructor(difficulty = 'medium') {
                this.difficulty = difficulty;
                this.depths = {
                    'easy': 1,
                    'medium': 2,
                    'hard': 3
                };
            }
            
            getMove(game) {
                const moves = game.getAllLegalMoves();
                if (moves.length === 0) return null;
                
                const depth = this.depths[this.difficulty] || 2;
                
                // –î–ª—è –ª–µ–≥–∫–æ–≥–æ —É—Ä–æ–≤–Ω—è –∏–Ω–æ–≥–¥–∞ –¥–µ–ª–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–µ —Ö–æ–¥—ã
                if (this.difficulty === 'easy' && Math.random() < 0.3) {
                    return moves[Math.floor(Math.random() * moves.length)];
                }
                
                let bestScore = game.currentPlayer === 'white' ? -Infinity : Infinity;
                let bestMoves = [];
                
                for (const move of moves) {
                    // –°–æ–∑–¥–∞–µ–º –≥–ª—É–±–æ–∫—É—é –∫–æ–ø–∏—é –∏–≥—Ä—ã
                    const testGame = game.clone();
                    
                    // –î–µ–ª–∞–µ–º —Ö–æ–¥
                    testGame.makeMove(move.fromRow, move.fromCol, move.toRow, move.toCol);
                    
                    // –û—Ü–µ–Ω–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é
                    let score;
                    if (depth > 1) {
                        score = this.minimax(testGame, depth - 1, -Infinity, Infinity, testGame.currentPlayer === 'white');
                    } else {
                        score = this.evaluatePosition(testGame);
                    }
                    
                    // –î–ª—è –±–µ–ª—ã—Ö –∏—â–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Å—á–µ—Ç, –¥–ª—è —á–µ—Ä–Ω—ã—Ö - –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π
                    if ((game.currentPlayer === 'white' && score > bestScore) ||
                        (game.currentPlayer === 'black' && score < bestScore)) {
                        bestScore = score;
                        bestMoves = [move];
                    } else if (score === bestScore) {
                        bestMoves.push(move);
                    }
                }
                
                return bestMoves.length > 0 ? bestMoves[Math.floor(Math.random() * bestMoves.length)] : moves[0];
            }
            
            minimax(game, depth, alpha, beta, maximizingPlayer) {
                if (depth === 0 || game.gameOver) {
                    return this.evaluatePosition(game);
                }
                
                const moves = game.getAllLegalMoves();
                
                if (maximizingPlayer) {
                    let maxEval = -Infinity;
                    for (const move of moves) {
                        const testGame = game.clone();
                        testGame.makeMove(move.fromRow, move.fromCol, move.toRow, move.toCol);
                        const eval = this.minimax(testGame, depth - 1, alpha, beta, false);
                        maxEval = Math.max(maxEval, eval);
                        alpha = Math.max(alpha, eval);
                        if (beta <= alpha) break;
                    }
                    return maxEval;
                } else {
                    let minEval = Infinity;
                    for (const move of moves) {
                        const testGame = game.clone();
                        testGame.makeMove(move.fromRow, move.fromCol, move.toRow, move.toCol);
                        const eval = this.minimax(testGame, depth - 1, alpha, beta, true);
                        minEval = Math.min(minEval, eval);
                        beta = Math.min(beta, eval);
                        if (beta <= alpha) break;
                    }
                    return minEval;
                }
            }
            
            evaluatePosition(game) {
                if (game.gameOver) {
                    if (game.winner === 'white') return 1000;
                    if (game.winner === 'black') return -1000;
                    return 0;
                }
                
                let score = 0;
                
                // –û—Ü–µ–Ω–∫–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–∞ –∏ –ø–æ–∑–∏—Ü–∏–∏
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 4; col++) {
                        const piece = game.board[row][col];
                        if (piece === 'white') {
                            score += 100;
                            // –ü–æ–∑–∏—Ü–∏–æ–Ω–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ –¥–ª—è –±–µ–ª—ã—Ö
                            score += (3 - row) * 15; // –ë–ª–∏–∑–æ—Å—Ç—å –∫ –ø–æ–±–µ–¥–µ
                            score += this.getControlBonus(row, col, 'white');
                            score += this.getSafetyBonus(game, row, col, 'white');
                        } else if (piece === 'black') {
                            score -= 100;
                            // –ü–æ–∑–∏—Ü–∏–æ–Ω–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ –¥–ª—è —á–µ—Ä–Ω—ã—Ö
                            score -= row * 15; // –ë–ª–∏–∑–æ—Å—Ç—å –∫ –ø–æ–±–µ–¥–µ
                            score -= this.getControlBonus(row, col, 'black');
                            score -= this.getSafetyBonus(game, row, col, 'black');
                        }
                    }
                }
                
                // –ú–æ–±–∏–ª—å–Ω–æ—Å—Ç—å
                const whiteMoves = game.currentPlayer === 'white' ? game.getAllLegalMoves().length : 0;
                const blackMoves = game.currentPlayer === 'black' ? game.getAllLegalMoves().length : 0;
                score += (whiteMoves - blackMoves) * 2;
                
                return score;
            }
            
            getControlBonus(row, col, player) {
                let bonus = 0;
                // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–µ –ø–æ–ª—è –±–æ–ª–µ–µ —Ü–µ–Ω–Ω—ã
                if (col === 1 || col === 2) bonus += 3;
                if (row === 1 || row === 2) bonus += 2;
                
                // –ö–æ–Ω—Ç—Ä–æ–ª—å –∫–ª—é—á–µ–≤—ã—Ö –ø–æ–ª–µ–π
                if (player === 'white') {
                    if (row === 2) bonus += 5; // –ü—Ä–µ–¥–ø–æ—Å–ª–µ–¥–Ω—è—è –ª–∏–Ω–∏—è
                } else {
                    if (row === 1) bonus += 5; // –ü—Ä–µ–¥–ø–æ—Å–ª–µ–¥–Ω—è—è –ª–∏–Ω–∏—è –¥–ª—è —á–µ—Ä–Ω—ã—Ö
                }
                
                return bonus;
            }
            
            getSafetyBonus(game, row, col, player) {
                let bonus = 0;
                const opponent = player === 'white' ? 'black' : 'white';
                
                // –ó–∞—â–∏—â–µ–Ω–Ω–æ—Å—Ç—å –ø–µ—à–∫–∏
                if (this.isProtected(game, row, col, player)) {
                    bonus += 8;
                }
                
                // –£–≥—Ä–æ–∑—ã –≤–∑—è—Ç–∏—è
                if (this.isUnderAttack(game, row, col, opponent)) {
                    bonus -= 10;
                }
                
                return bonus;
            }
            
            isProtected(game, row, col, player) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞—â–∏—â–µ–Ω–∞ –ª–∏ –ø–µ—à–∫–∞ –¥—Ä—É–≥–æ–π –ø–µ—à–∫–æ–π
                const directions = player === 'white' 
                    ? [[-1, -1], [-1, 1]]  // –ë–µ–ª—ã–µ –∑–∞—â–∏—â–∞—é—Ç—Å—è —Å–∑–∞–¥–∏-–ø–æ-–¥–∏–∞–≥–æ–Ω–∞–ª–∏
                    : [[1, -1], [1, 1]];   // –ß–µ—Ä–Ω—ã–µ –∑–∞—â–∏—â–∞—é—Ç—Å—è —Å–∑–∞–¥–∏-–ø–æ-–¥–∏–∞–≥–æ–Ω–∞–ª–∏
                    
                for (const [dr, dc] of directions) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (newRow >= 0 && newRow < 4 && newCol >= 0 && newCol < 4) {
                        if (game.board[newRow][newCol] === player) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            isUnderAttack(game, row, col, opponent) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞—Ç–∞–∫–æ–≤–∞–Ω–∞ –ª–∏ –ø–µ—à–∫–∞
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 4; c++) {
                        if (game.board[r][c] === opponent) {
                            const captureDirections = opponent === 'black' 
                                ? [[-1, -1], [-1, 1], [0, -1], [0, 1]]
                                : [[1, -1], [1, 1], [0, -1], [0, 1]];
                            
                            for (const [dr, dc] of captureDirections) {
                                if (r + dr === row && c + dc === col) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }
        }

        class GameUI {
            constructor() {
                this.game = new MicroChess();
                this.botWhite = null;
                this.botBlack = null;
                this.gameMode = 'pvp';
                this.isBotThinking = false;
                this.initializeBoard();
                this.setupEventListeners();
                this.updateUI();
            }
            
            initializeBoard() {
                const board = document.getElementById('board');
                board.innerHTML = '';
                
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 4; col++) {
                        const cell = document.createElement('div');
                        cell.className = `cell ${(row + col) % 2 === 0 ? '' : 'dark'}`;
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        // –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
                        const colCoord = document.createElement('div');
                        colCoord.className = 'coordinates coord-col';
                        colCoord.textContent = 'abcd'[col];
                        
                        const rowCoord = document.createElement('div');
                        rowCoord.className = 'coordinates coord-row';
                        rowCoord.textContent = 4 - row;
                        
                        cell.appendChild(colCoord);
                        cell.appendChild(rowCoord);
                        
                        cell.addEventListener('click', () => this.handleCellClick(row, col));
                        board.appendChild(cell);
                    }
                }
            }
            
            setupEventListeners() {
                document.getElementById('newGameBtn').addEventListener('click', () => this.newGame());
                document.getElementById('undoBtn').addEventListener('click', () => this.undoMove());
                document.getElementById('gameModeSelect').addEventListener('change', (e) => {
                    this.gameMode = e.target.value;
                    this.newGame();
                });
            }
            
            handleCellClick(row, col) {
                if (this.game.gameOver || this.isBotThinking) return;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–µ–∫—É—â–∏–π –∏–≥—Ä–æ–∫ –±–æ—Ç–æ–º
                const currentBot = this.game.currentPlayer === 'white' ? this.botWhite : this.botBlack;
                if (currentBot) return;
                
                // –ï—Å–ª–∏ –∫–ª–µ—Ç–∫–∞ —É–∂–µ –≤—ã–±—Ä–∞–Ω–∞, –¥–µ–ª–∞–µ–º —Ö–æ–¥
                if (this.game.selectedCell) {
                    const [selectedRow, selectedCol] = this.game.selectedCell;
                    const move = this.game.possibleMoves.find(m => m.row === row && m.col === col);
                    
                    if (move) {
                        this.makeMove(selectedRow, selectedCol, row, col);
                    }
                    this.clearSelection();
                } else {
                    // –í—ã–±–∏—Ä–∞–µ–º –∫–ª–µ—Ç–∫—É
                    if (this.game.board[row][col] === this.game.currentPlayer) {
                        this.game.selectedCell = [row, col];
                        this.game.possibleMoves = this.game.getPossibleMoves(row, col);
                        this.updateUI();
                    }
                }
            }
            
            makeMove(fromRow, fromCol, toRow, toCol) {
                const moveResult = this.game.makeMove(fromRow, fromCol, toRow, toCol);
                this.addMoveToHistory(moveResult);
                this.updateUI();
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å –ª–∏ –∏–≥—Ä–∞
                if (!this.game.gameOver) {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–æ–ª–∂–µ–Ω –ª–∏ —Å–ª–µ–¥—É—é—â–∏–π —Ö–æ–¥ —Å–¥–µ–ª–∞—Ç—å –±–æ—Ç
                    this.checkBotMove();
                }
            }
            
            addMoveToHistory(move) {
                const movesList = document.getElementById('movesList');
                const moveElement = document.createElement('div');
                moveElement.className = 'move-record';
                
                const player = move.player === 'white' ? '–ë–µ–ª—ã–µ' : '–ß–µ—Ä–Ω—ã–µ';
                const captureText = move.capture ? ' √ó ' : ' ‚Üí ';
                
                moveElement.innerHTML = `
                    <span>${player}</span>
                    <span>${move.from}${captureText}${move.to}</span>
                `;
                
                movesList.appendChild(moveElement);
                movesList.scrollTop = movesList.scrollHeight;
            }
            
            checkBotMove() {
                const currentBot = this.game.currentPlayer === 'white' ? this.botWhite : this.botBlack;
                
                if (currentBot && !this.game.gameOver) {
                    this.isBotThinking = true;
                    this.updateUI();
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–±–æ–ª—å—à—É—é –∑–∞–¥–µ—Ä–∂–∫—É –¥–ª—è "—Ä–∞–∑–¥—É–º–∏–π" –±–æ—Ç–∞
                    setTimeout(() => {
                        const move = currentBot.getMove(this.game);
                        if (move) {
                            this.makeMove(move.fromRow, move.fromCol, move.toRow, move.toCol);
                        }
                        this.isBotThinking = false;
                    }, 500);
                }
            }
            
            clearSelection() {
                this.game.selectedCell = null;
                this.game.possibleMoves = [];
                this.updateUI();
            }
            
            updateUI() {
                // –û–±–Ω–æ–≤–ª—è–µ–º –¥–æ—Å–∫—É
                const cells = document.querySelectorAll('.cell');
                cells.forEach(cell => {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    const piece = this.game.board[row][col];
                    
                    // –û—á–∏—â–∞–µ–º –∫–ª–µ—Ç–∫—É
                    cell.innerHTML = '';
                    
                    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
                    const colCoord = document.createElement('div');
                    colCoord.className = 'coordinates coord-col';
                    colCoord.textContent = 'abcd'[col];
                    
                    const rowCoord = document.createElement('div');
                    rowCoord.className = 'coordinates coord-row';
                    rowCoord.textContent = 4 - row;
                    
                    cell.appendChild(colCoord);
                    cell.appendChild(rowCoord);
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º –ø–µ—à–∫—É, –µ—Å–ª–∏ –µ—Å—Ç—å
                    if (piece) {
                        const pawn = document.createElement('div');
                        pawn.className = `pawn ${piece}`;
                        pawn.textContent = '‚ôü';
                        cell.appendChild(pawn);
                    }
                    
                    // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—É—é –∫–ª–µ—Ç–∫—É –∏ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Ö–æ–¥—ã
                    cell.classList.remove('selected', 'possible-move', 'possible-capture');
                    
                    if (this.game.selectedCell && this.game.selectedCell[0] === row && this.game.selectedCell[1] === col) {
                        cell.classList.add('selected');
                    }
                    
                    const possibleMove = this.game.possibleMoves.find(m => m.row === row && m.col === col);
                    if (possibleMove) {
                        cell.classList.add(possibleMove.type === 'capture' ? 'possible-capture' : 'possible-move');
                    }
                });
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∏–≥—Ä–æ–∫–µ
                document.getElementById('currentPlayer').textContent = 
                    `–•–æ–¥: ${this.game.currentPlayer === 'white' ? '–ë–µ–ª—ã–µ' : '–ß–µ—Ä–Ω—ã–µ'}`;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∏–≥—Ä—ã
                const status = document.getElementById('status');
                if (this.game.gameOver) {
                    if (this.game.winner) {
                        status.textContent = `üéâ –ü–æ–±–µ–¥–∞ ${this.game.winner === 'white' ? '–±–µ–ª—ã—Ö' : '—á–µ—Ä–Ω—ã—Ö'}!`;
                        status.style.background = '#4CAF50';
                    } else {
                        status.textContent = 'ü§ù –ù–∏—á—å—è!';
                        status.style.background = '#FF9800';
                    }
                } else if (this.isBotThinking) {
                    status.textContent = 'ü§ñ –ë–æ—Ç –¥—É–º–∞–µ—Ç...';
                    status.style.background = '#2196F3';
                } else {
                    status.textContent = `–ò–≥—Ä–∞ –∏–¥–µ—Ç. –•–æ–¥: ${this.game.currentPlayer === 'white' ? '–±–µ–ª—ã—Ö' : '—á–µ—Ä–Ω—ã—Ö'}`;
                    status.style.background = 'rgba(0, 0, 0, 0.2)';
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ä–µ–∂–∏–º–µ –∏–≥—Ä—ã
                const modeText = {
                    'pvp': '–ò–≥—Ä–æ–∫ vs –ò–≥—Ä–æ–∫',
                    'pve_easy': '–ò–≥—Ä–æ–∫ vs –ë–æ—Ç (–õ–µ–≥–∫–∏–π)',
                    'pve_medium': '–ò–≥—Ä–æ–∫ vs –ë–æ—Ç (–°—Ä–µ–¥–Ω–∏–π)',
                    'pve_hard': '–ò–≥—Ä–æ–∫ vs –ë–æ—Ç (–°–ª–æ–∂–Ω—ã–π)',
                    'eve': '–ë–æ—Ç vs –ë–æ—Ç'
                };
                document.getElementById('gameMode').textContent = `–†–µ–∂–∏–º: ${modeText[this.gameMode]}`;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É –æ—Ç–º–µ–Ω—ã —Ö–æ–¥–∞
                document.getElementById('undoBtn').disabled = this.game.moveHistory.length === 0;
            }
            
            newGame() {
                this.game = new MicroChess();
                
                // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –±–æ—Ç–æ–≤ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–µ–∂–∏–º–∞ –∏–≥—Ä—ã
                this.botWhite = null;
                this.botBlack = null;
                
                switch (this.gameMode) {
                    case 'pve_easy':
                        this.botBlack = new SmartBot('easy');
                        break;
                    case 'pve_medium':
                        this.botBlack = new SmartBot('medium');
                        break;
                    case 'pve_hard':
                        this.botBlack = new SmartBot('hard');
                        break;
                    case 'eve':
                        this.botWhite = new SmartBot('medium');
                        this.botBlack = new SmartBot('hard');
                        break;
                }
                
                // –û—á–∏—â–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é —Ö–æ–¥–æ–≤
                document.getElementById('movesList').innerHTML = '';
                
                this.clearSelection();
                this.updateUI();
                
                // –ï—Å–ª–∏ –ø–µ—Ä–≤—ã–π —Ö–æ–¥ –∑–∞ –±–æ—Ç–æ–º
                this.checkBotMove();
            }
            
            undoMove() {
                if (this.game.undoMove()) {
                    // –£–¥–∞–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ö–æ–¥ –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏
                    const movesList = document.getElementById('movesList');
                    if (movesList.lastChild) {
                        movesList.removeChild(movesList.lastChild);
                    }
                    this.updateUI();
                }
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        document.addEventListener('DOMContentLoaded', () => {
            new GameUI();
        });
    </script>
</body>
</html>
